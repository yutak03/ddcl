---
description: Rustのプロジェクトの普遍ルール
globs: *.rs,*.toml
---

# Rust Project Rules

Rustプロジェクトのベストプラクティスとコーディング規約

## 前提
- すでにRustがインストールされている
- rust-toolchain.tomlを使う
	- なければ作成する
- 2024エディションを使う
- rustup check で最新バージョンのRustじゃない場合は更新する
- プロジェクトの初期化がまだの場合はcargo initを使って初期化する
- 指示されたタスクを実行する前に、遂行する予定のことをユーザに提示し、実行するかどうかの指示を仰ぐ

## ユーザの指示について
- ステップバイステップで考える
- 同じ修正が5回以上繰り返し失敗した場合は、以下の内容をユーザに提示して指示を仰ぐ
	- エラー内容
	- 試したこと
	- 他に試そうとしていること

## モジュールの設計
- Rustのstdモジュール設計方針に準ずる
- pub useを活用して適切なAPIを公開する
- モジュールは単一責任の原則に従って分割する
- 内部実装の詳細は非公開にする
- 大きな関数やメソッドは責務単位で小さな関数に分割する（100 ~ 150行以内を目標）

## エラー処理

Rustのエラー処理パターンに関するルール

- Result<T, E>を適切に使用し、unwrap()やexpect()の使用は最小限に抑える
	- Resultが利用できない、たとえばArc<Mutex>のような場合はtry_unwrap()といったより安全に処理すること
- テストではunwrap()やexpect()を積極的に使ってよい
- カスタムエラー型はthiserror crateを使用して定義する
- エラー伝播には?演算子を使用する
- サードパーティのクレートのエラーハンドリングにはanyhowを利用する
	- stdのResultと区別しやすくするため、必ずanyhow::Resultと記述する
	- エラー種別に応じて具体的なハンドリングが必要な場合、次のようにisメソッドを使う
	  ```rs
	  async fn fetch() -> anyhow::Result<...> {
	  	let result = sqlx::query_as!(T, "...").await?;
	  	// do something
	  	Ok(...)
	  }
	  
	  // sqlxが返すエラーをハンドリングする
	  async fn call_fetch() -> Result<(), AppError> {
	  	let result = fetch().await;
	  	if result.is::<sqlx::RowNotFound>() {
	  		return Err(AppError::NoResource(result.string()))
	  	}
	  
	  	...
	  
	  	Ok(())
	  }
	  ```

## ライフタイム管理

メモリ安全性を確保するためのライフタイムルール

- 不必要なライフタイムアノテーションを避ける（ライフタイムの省略ルールを活用する）
- 複雑なライフタイム関係には明示的なアノテーションを使用する
	- 複雑過ぎた場合は参照ではなく、値を持つまたは引き取るを検討する
- 静的ライフタイム('static)の使用は慎重に行う

## 依存性の管理

依存関係の注入と管理に関するルール

- 外部依存はコンストラクタまたは構造体の初期化時に注入する
- グローバル状態の使用を避け、必要な場合はonce_cell::sync::Lazyなどを検討する
- テスト時にモックに置き換え可能な設計にする
- Cargo.tomlでは依存関係のバージョンを明示的に指定する

## 型システムの活用

Rustの型システムを最大限に活用するためのルール

- newtype patternを使用して型安全性を高める
- ジェネリクスを適切に活用して重複コードを減らす
- トレイト境界を使用して型の振る舞いを制限する
- 型エイリアスを使用して複雑な型シグネチャを簡略化する

## テスト

テストに関するベストプラクティス

- ユニットテストはモジュール内の#[cfg(test)]セクションに記述する
- モックが必要な場合はmockallを使用する
- 統合テストはtestsディレクトリに配置する
- テスト用のヘルパー関数やモックは適切に分離する
	- ユニットと統合テストのヘルパー関数も基本的に単一責任原則に従ってファイルと関数を分ける
- エッジケースを含む包括的なテストを書く
- テストカバレッジは基本的に80%以上をキープする
	- カバレッジの確認はcargo-llvm-covとllvm-tools-previewを使う
	- テスト後は必ずカバレッジを確認する
	- htmlに出力してブラウザで確認するかをユーザに尋ねる
- 公開APIは必ずdocテストを書く

## パフォーマンス

パフォーマンスに関する考慮事項

- クリティカルパスでのアロケーションを最小限に抑える
- 必要に応じてベンチマークを作成して最適化の効果を測定する
- 大きなデータ構造の場合は参照を使用する
	- ただし実装が複雑になる場合はコピーを使って良い
- 非同期コードでは基本的にtokioを使用する
	- ただし規模と用途に応じてsmolやfutures-rsを使用してよい
	- ただしCPUバウンドな処理はrayon-rsを使用すること
	- CPUバウンドとIOバウンドが平行で存在する場合tokioを優先的に使う
		- その際はblockingスレッドを利用する

## ドキュメント

コードドキュメントに関するルール

- パブリックAPIには常にドキュメントコメント(///)を付ける
- ドキュメントには使用例を含める
- 複雑なロジックには通常のコメント(//)で説明を追加する
	- コメントは実装から読み取れない背景や、複雑な処理を要約するときに書く
	- 処理を翻訳しただけのコメント、またはトレイト実装のメソッドは書かない
- TODOコメントにはチケット番号や課題の詳細を含める

## ビルドと設定

ビルドプロセスと設定に関するルール

- 複数のターゲット環境がある場合は条件付きコンパイル(#[cfg(...)])を活用する
- ビルドスクリプト(build.rs)は必要な場合のみ使用し、シンプルに保つ
- 環境変数による設定は.envファイルと https://github.com/allan2/dotenvy クレートを使用して管理する
- リリースビルドでは最適化レベルを適切に設定する（Cargo.tomlの[profile.release]セクション）
- デバッグシンボルの扱いを明確にする（開発環境では含め、本番環境では除外するなど）
- Linux向けのターゲットビルド時は基本的にmuslを使用して静的リンクする
- Linuxの場合、ビルド時間短縮のためリンカーは https://github.com/rui314/mold を使う

## クレートの選定

外部クレートの選択と利用に関するガイドライン

- 広く使われている安定したクレートを優先する（ダウンロード数、GitHub Starsなどを参考に）
- メンテナンスが活発なクレートを選ぶ（最終更新日、Issue対応状況を確認）
- セキュリティ脆弱性がないか定期的に確認する（cargo-audit等を使用）
- 依存関係の数が少ないクレートを優先する（cargo-deps等で確認）
- 標準的なユースケース向けの推奨クレート：
  - シリアライズ/デシリアライズ: serde
  - CLIアプリケーション: clap
  - 非同期プログラミング: tokio, async-std
  - HTTPクライアント: reqwest, ureq
  - HTTPサーバー: axum, actix-web, rocket
  - データベース: sqlx, diesel
  - ロギング: tracing, log + env_logger
  - エラー処理: thiserror, anyhow
  - 日付と時刻: chrono, time
  - 暗号化: ring, rustls
  - テスト: mockall, proptest

## CIの設定について
- カバレッジのレポートは https://github.com/k1LoW/octocov を使う
	- octocov init で生成したconfigファイルを基本的にそのまま使う
- workflow/job/runの名前は基本的に英語で記述する

## 実装の選択基準

1. 関数を選ぶ場合
	- 単純な操作のみ
	- 内部状態が不要
	- 依存が少ない
	- テストが容易

2. 構造体を選ぶ場合
	- 内部状態の管理が必要
	- 設定やリソースの保持が必要
	- メソッド間で状態を共有
	- ライフサイクル管理が必要

3. トレイトを選ぶ場合
	- 外部依存の抽象化
	- テスト時のモック化が必要
	- 実装の詳細を隠蔽したい
	- 差し替え可能性を確保したい

# 一般的なルール

1. 依存性の注入
   - 外部依存はコンストラクタで注入
   - テスト時にモックに置き換え可能に
   - グローバルな状態を避ける

2. インターフェースの設計
   - 必要最小限のメソッドを定義
   - 実装の詳細を含めない
   - プラットフォーム固有の型を避ける

3. テスト容易性
   - モックの実装を簡潔に
   - エッジケースのテストを含める
   - テストヘルパーを適切に分離

4. コードの分割
   - 単一責任の原則に従う

## pull request作成手順

### 必須前提条件
- Issue番号の確認
  - Issueのリンクが提供されていない場合は、必ずユーザーに「関連するIssueのリンクはありますか？」と確認する
  - Issueが存在しない場合は、その旨をPRの説明に明記する

### 差分の確認
- {{マージ先ブランチ}}は特に指示がなければ main とする
- `git diff origin/{{マージ先ブランチ}}...HEAD | cat` でマージ先ブランチとの差分を確認

### descriptionに記載するリンクの準備
- Issueのリンクを確認（必須前提条件で確認済みであること）

### Pull Request 作成とブラウザでの表示
- 以下のコマンドでpull requestを作成し、自動的にブラウザで開く
- PRタイトルおよびPRテンプレートはマージ先との差分をもとに適切な内容にする
- 指示がない限りDraftでpull requestを作成
- `{{PRテンプレートを1行に変換}}`の部分はPRテンプレートの内容を`\n`で改行表現した1行の文字列
- 各セクションを明確に区分
- 必要な情報を漏れなく記載

---
git push origin HEAD && \
echo -e "{{PRテンプレートを1行に変換}}" | \
gh pr create --draft --title "{{PRタイトル}}" --body-file - && \
gh pr view --web
---

#### PRテンプレート

@PULL_REQUEST_TEMPLATE.md からテンプレート内容を取得すること
